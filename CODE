// ðŸŸ¢ HABIT TRACKER CORE
// Version 2.1

const FILE_NAME = "habit_tracker_data.json";
const KEYCHAIN_HABITS_KEY = "multiHabitTrackerHabits";
const KEYCHAIN_STORAGE_KEY = "multiHabitTrackerData";
const KEYCHAIN_THEME_KEY = "multiHabitTrackerTheme";

let fm;
try {
  fm = FileManager.iCloud();
} catch (e) {
  fm = FileManager.local();
}

// ðŸ”µ DEFAULT CONFIG
const DEFAULT_THEME = "dark";
const THEMES = {
  dark: { background: "#000000", text: "#ffffff" },
  light: { background: "#ffffff", text: "#454545" },
  midnight: { background: "#0D1B2A", text: "#E0E1DD" },
  solarized: { background: "#002B36", text: "#839496" },
  nordic: { background: "#2E3440", text: "#D8DEE9" },
  paper: { background: "#FDF6E3", text: "#586E75" },
  pink: { background: "#FFC0CB", text: "#8B5D68" }
};

const THEME_NAMES = [
  "Classic Dark", "Classic Light", "Midnight Blue",
  "Solarized Dark", "Nordic Night", "Paper White", "Sweet Pink"
];

const DEFAULT_HABIT_COLORS = [
  "#FF595E", "#FFCA3A", "#8AC926", "#1982C4", "#6A4C93", "#F15BB5"
];

// ðŸ”µ FILE SYSTEM MANAGEMENT
function getFilePath() {
  const dir = fm.documentsDirectory();
  return fm.joinPath(dir, FILE_NAME);
}

async function loadData() {
  const path = getFilePath();

  if (fm.fileExists(path)) {
    if (fm.isFileStoredIniCloud(path)) {
      await fm.downloadFileFromiCloud(path);
    }
    const json = fm.readString(path);
    return JSON.parse(json);
  } else {
    return await migrateFromKeychain();
  }
}

function saveData(data) {
  const path = getFilePath();
  fm.writeString(path, JSON.stringify(data, null, 2));
}

async function migrateFromKeychain() {
  console.log("Checking for legacy Keychain data...");
  let habits = [];
  let settings = { theme: DEFAULT_THEME };

  if (Keychain.contains(KEYCHAIN_THEME_KEY)) {
    const t = Keychain.get(KEYCHAIN_THEME_KEY);
    if (THEMES[t]) settings.theme = t;
  }

  let habitNames = [];
  if (Keychain.contains(KEYCHAIN_HABITS_KEY)) {
    try {
      habitNames = JSON.parse(Keychain.get(KEYCHAIN_HABITS_KEY));
    } catch (e) { console.error(e); }
  }

  if (Keychain.contains(KEYCHAIN_STORAGE_KEY)) {
    try {
      const raw = Keychain.get(KEYCHAIN_STORAGE_KEY);
      const parsed = JSON.parse(raw);

      habitNames.forEach((name, index) => {
        const historyArray = parsed.habits[name] || [];
        let historyMap = {};
        historyArray.forEach(date => { historyMap[date] = 1; });

        habits.push({
          id: generateUUID(),
          name: name,
          icon: "circle.fill", // Default icon
          color: DEFAULT_HABIT_COLORS[index % DEFAULT_HABIT_COLORS.length],
          target: 1,
          history: historyMap
        });
      });

    } catch (e) { console.error("Migration error: " + e); }
  } else {
    habits = [
      { id: generateUUID(), name: "Water", icon: "drop.fill", color: "#64D2FF", target: 1, history: {} },
      { id: generateUUID(), name: "Read", icon: "book.fill", color: "#FFD60A", target: 1, history: {} }
    ];
  }

  const newData = { settings, habits };
  saveData(newData);
  return newData;
}

// ðŸ”µ HELPER FUNCTIONS
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function daysInMonth(month, year) {
  return new Date(year, month, 0).getDate();
}

function generateMonthDates(year, month) {
  const days = daysInMonth(month, year);
  const dates = [];
  for (let d = 1; d <= days; d++) {
    dates.push(`${year}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`);
  }
  return dates;
}

// ðŸ”µ UI: WIDGET RENDERING
function createWidget(data, widgetFamily) {
  const { settings, habits } = data;
  const theme = THEMES[settings.theme] || THEMES.dark;

  const w = new ListWidget();
  w.backgroundColor = new Color(theme.background);
  w.setPadding(12, 0, 12, 0);

  // Config
  const ICON_SIZE = new Size(21, 21);
  const DOT_SIZE = new Size(21, 21);
  const DOT_SPACING = 0;
  const ROW_SPACING = 0;
  let COLUMNS = 14; // Fixed width 14 days

  // Adaptive Logic
  const habitCount = habits.length;
  let rowsPerHabit = 1;
  let laneSpacing = 6;
  let maxHabitsToShow = 6;

  if (widgetFamily !== "small") {
    if (habitCount === 1) { rowsPerHabit = 7; laneSpacing = 0; }
    else if (habitCount === 2) { rowsPerHabit = 3; laneSpacing = 4; }
    else if (habitCount === 3) { rowsPerHabit = 2; laneSpacing = 2; }
    else if (habitCount >= 4) { rowsPerHabit = 1; laneSpacing = (habitCount > 5) ? 2 : 4; }
  } else {
    // Small widget fallback
    maxHabitsToShow = 4;
    COLUMNS = 5;
  }

  const habitsToShow = habits.slice(0, maxHabitsToShow);

  if (habitsToShow.length === 0) {
    const t = w.addText("No habits set.");
    t.textColor = new Color(theme.text);
    return w;
  }

  // Pre-load Symbols
  const dotSymbol = SFSymbol.named("square.fill");

  habitsToShow.forEach(habit => {
    // LANE (Horizontal: Icon + Grid)
    const lane = w.addStack();
    lane.layoutHorizontally();
    lane.centerAlignContent(); // Vertically center icon relative to grid

    // 1. Spacer Left
    lane.addSpacer();

    // 2. Icon (Centered in Lane)
    const iconFn = SFSymbol.named(habit.icon) || SFSymbol.named("circle.fill");
    const iconImg = lane.addImage(iconFn.image);
    iconImg.imageSize = ICON_SIZE;
    iconImg.tintColor = new Color(habit.color);

    // Tap to Increment
    const scriptName = Script.name();
    const url = `scriptable:///run/${encodeURIComponent(scriptName)}?habitName=${encodeURIComponent(habit.name)}&action=increment`;
    iconImg.url = url;

    lane.addSpacer(2); // Spacing between Icon and Grid

    // 3. Grid Stack (Vertical: Holds multiple rows of dots)
    const gridStack = lane.addStack();
    gridStack.layoutVertically();

    // Render Rows (History)
    for (let r = 0; r < rowsPerHabit; r++) {
      const rowStack = gridStack.addStack();
      rowStack.layoutHorizontally();

      // In a multi-row view, usually Top is "Current". 
      // Row 0: [Today-13 ... Today]
      // Row 1: [Today-27 ... Today-14]
      // Offset = r * COLUMNS

      // We generate dates right to left (Newest to Oldest) visually? 
      // Actually "dates.push" logic usually goes Oldest -> Newest (Left -> Right).
      // So for Row 0, we want [Today-13 ... Today].
      // For Row 1, we want [Today-27 ... Today-14].

      // Let's calculate the "End Date" for this row.
      // Row 0 End = Today.
      // Row 1 End = Today - 14 days.
      const rowOffsetDays = r * COLUMNS;

      // Generate dots for this row
      // Iterate `i` from COLUMNS-1 down to 0 to generate [Oldest ... Newest] in this chunk
      for (let c = COLUMNS - 1; c >= 0; c--) {
        const dayOffset = rowOffsetDays + c;

        const d = new Date();
        d.setDate(d.getDate() - dayOffset);
        const dateStr = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;

        // Get Data
        const count = habit.history[dateStr] || 0;
        const target = habit.target || 1;
        const opacity = count > 0 ? Math.min(count / target, 1.0) : 0.15;
        const isToday = (dayOffset === 0);

        const dotImg = rowStack.addImage(dotSymbol.image);
        dotImg.imageSize = DOT_SIZE;

        let color;
        if (count === 0) {
          color = new Color(theme.text, 0.2);
          if (isToday) color = new Color(theme.text, 0.6);
        } else {
          color = new Color(habit.color, opacity);
        }
        dotImg.tintColor = color;

        if (c > 0) rowStack.addSpacer(DOT_SPACING);
      }

      if (r < rowsPerHabit - 1) gridStack.addSpacer(ROW_SPACING);
    }

    // 4. Spacer Right
    lane.addSpacer(); // Centers the block

    w.addSpacer(laneSpacing); // Spacing between habits
  });

  return w;
}

// ðŸ”µ UI: ADMIN TOOLS
async function presentMainMenu(data) {
  const alert = new Alert();
  alert.title = "Habit Tracker Options";
  alert.addAction("Manage Habits");
  alert.addAction("Set Theme");
  alert.addCancelAction("Exit");

  const response = await alert.presentSheet();

  if (response === 0) {
    await presentHabitManager(data);
  } else if (response === 1) {
    await presentThemePicker(data);
    await presentMainMenu(data);
  }
}

async function presentHabitManager(data) {
  const table = new UITable();
  table.showSeparators = true;

  // Header (Pseudo-header to allow dismissOnSelect)
  const navRow = new UITableRow();
  navRow.height = 60;
  navRow.dismissOnSelect = true; // Essential for refreshing the table without stacking

  // Title
  const titleCell = navRow.addText("Manage Habits");
  titleCell.titleFont = Font.mediumSystemFont(22);
  titleCell.widthWeight = 10;

  // Add "+" Action
  const plusIcon = SFSymbol.named("plus");
  const addCell = navRow.addImage(plusIcon.image);
  addCell.widthWeight = 1;
  addCell.rightAligned();

  // Entire row triggers the action to support dismissal
  navRow.onSelect = async () => {
    await presentHabitForm(data);
    await presentHabitManager(data);
  }
  table.addRow(navRow);

  // Existing Habits
  data.habits.forEach((habit, index) => {
    const row = new UITableRow();
    row.height = 60;
    row.dismissOnSelect = true;
    row.cellSpacing = 12;

    // Icon
    const iconFn = SFSymbol.named(habit.icon) || SFSymbol.named("circle.fill");
    const imageCell = row.addImage(iconFn.image);
    imageCell.widthWeight = 1;
    imageCell.tintColor = new Color(habit.color);

    // Info
    const textCell = row.addText(habit.name, `Target: ${habit.target} | Color: ${habit.color}`);
    textCell.widthWeight = 8;
    textCell.titleFont = Font.systemFont(16);
    textCell.subtitleFont = Font.systemFont(12);
    textCell.subtitleColor = Color.gray();

    // Edit Action
    row.onSelect = async () => {
      await presentHabitActionSheet(data, habit, index);
      await presentHabitManager(data);
    };

    table.addRow(row);
  });

  await table.present();
}

async function presentThemePicker(data) {
  const a = new Alert();
  a.title = "Select Theme";
  THEME_NAMES.forEach(name => a.addAction(name));
  a.addCancelAction("Cancel");

  const choice = await a.presentSheet();
  if (choice >= 0 && choice < THEME_NAMES.length) {
    const keys = Object.keys(THEMES);
    if (choice < keys.length) {
      data.settings.theme = keys[choice];
      saveData(data);
    }
  }
}

async function presentHabitActionSheet(data, habit, index) {
  const a = new Alert();
  a.title = habit.name;
  a.message = "Choose an action";
  a.addAction("Edit Details");
  a.addAction("Manual Entry");
  a.addDestructiveAction("Delete Habit");
  a.addCancelAction("Cancel");

  const choice = await a.presentSheet();
  if (choice === 0) {
    await presentHabitForm(data, habit, index);
  } else if (choice === 1) {
    await presentManualEntry(data, habit);
  } else if (choice === 2) {
    if (await confirmDelete(habit.name)) {
      data.habits.splice(index, 1);
      saveData(data);
    }
  }
}

async function presentManualEntry(data, habit) {
  // 1. Pick Date
  try {
    const picker = new DatePicker();
    picker.initialDate = new Date();
    const date = await picker.pickDate();

    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

    // 2. Get Current Value
    const currentVal = habit.history[dateStr] || 0;

    // 3. Prompt for new value
    const alert = new Alert();
    alert.title = `Set value for ${dateStr}`;
    alert.message = `Current value: ${currentVal}`;
    alert.addTextField("Count", String(currentVal));
    alert.addAction("Save");
    alert.addDestructiveAction("Clear Entry");
    alert.addCancelAction("Cancel");

    const response = await alert.presentAlert();

    if (response === 0) { // Save
      const input = alert.textFieldValue(0);
      const val = parseInt(input);
      if (!isNaN(val) && val > 0) {
        habit.history[dateStr] = val;
      } else {
        delete habit.history[dateStr];
      }
      saveData(data);
      const n = new Notification();
      n.title = "Entry Saved";
      n.body = `${habit.name} on ${dateStr}: ${val || 0}`;
      n.schedule();

    } else if (response === 1) { // Clear
      delete habit.history[dateStr];
      saveData(data);
    }

  } catch (e) {
    // Picker cancelled or error
  }
}

async function confirmDelete(name) {
  const a = new Alert();
  a.title = `Delete ${name}?`;
  a.message = "This cannot be undone.";
  a.addDestructiveAction("Delete");
  a.addCancelAction("Cancel");
  return (await a.presentAlert()) === 0;
}

async function presentHabitForm(data, habit = null, index = null) {
  const isEdit = habit !== null;
  const alert = new Alert();
  alert.title = isEdit ? "Edit Habit" : "New Habit";

  alert.addTextField("Name", isEdit ? habit.name : "");
  alert.addTextField("Icon (SFSymbol)", isEdit ? habit.icon : "star.fill");
  alert.addTextField("Color (Hex)", isEdit ? habit.color : DEFAULT_HABIT_COLORS[data.habits.length % DEFAULT_HABIT_COLORS.length]);
  alert.addTextField("Target (Daily)", isEdit ? String(habit.target) : "1");

  alert.addAction("Save");
  alert.addCancelAction("Cancel");

  const response = await alert.presentAlert();

  if (response === 0) {
    const name = alert.textFieldValue(0).trim();
    const icon = alert.textFieldValue(1).trim();
    const color = alert.textFieldValue(2).trim();
    const target = parseInt(alert.textFieldValue(3).trim()) || 1;

    if (name.length === 0) return; // Validation

    const newHabit = {
      id: isEdit ? habit.id : generateUUID(),
      name: name,
      icon: icon,
      color: color,
      target: target,
      history: isEdit ? habit.history : {}
    };

    if (isEdit) {
      data.habits[index] = newHabit;
    } else {
      data.habits.push(newHabit);
    }

    saveData(data);
  }
}

// ðŸ”µ MAIN ENTRY
async function main() {
  const data = await loadData();

  // 1. Handle URL Scheme (Widget Tap or Open URL via Shortcut)
  if (args.queryParameters["action"] === "increment") {
    // Case A: ID provided (Widget)
    if (args.queryParameters["habitId"]) {
      await incrementHabit(data, args.queryParameters["habitId"]);
      return;
    }

    // Case B: Name provided (Shortcut URL)
    if (args.queryParameters["habitName"]) {
      const name = args.queryParameters["habitName"];
      const habit = data.habits.find(h => h.name.toLowerCase() === name.toLowerCase());
      if (habit) {
        await incrementHabit(data, habit.id);
      } else {
        const n = new Notification();
        n.title = "Habit Not Found";
        n.body = `Could not find habit named '${name}'`;
        n.schedule();
      }
      return;
    }
  }

  // 2. Handle Shortcut Input (e.g. "Water" or {"name": "Water"})
  if (args.shortcutParameter) {
    let param = args.shortcutParameter;
    let habitName = null;

    // Check if valid JSON object or simple string
    if (typeof param === "string") {
      habitName = param;
    } else if (typeof param === "object" && param.name) {
      habitName = param.name;
    }

    if (habitName) {
      // Find by name
      const habit = data.habits.find(h => h.name.toLowerCase() === habitName.toLowerCase());
      if (habit) {
        await incrementHabit(data, habit.id);
      } else {
        const n = new Notification();
        n.title = "Habit Not Found";
        n.body = `Could not find habit named '${habitName}'`;
        n.schedule();
      }
    }
    return;
  }

  // 3. Run UI (Widget or App)
  if (config.runsInWidget) {
    const w = createWidget(data, config.widgetFamily);
    Script.setWidget(w);
  } else {
    // In-App Dashboard
    await presentMainMenu(data);
  }
}

async function incrementHabit(data, habitId) {
  const habitIndex = data.habits.findIndex(h => h.id === habitId);
  if (habitIndex === -1) return;

  const now = new Date();
  const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

  // Update Data
  const habit = data.habits[habitIndex];
  habit.history[dateStr] = (habit.history[dateStr] || 0) + 1;
  saveData(data);

  // Subtle feedback only
  try { Device.vibrate(); } catch (e) { }
}

await main();
Script.complete();
