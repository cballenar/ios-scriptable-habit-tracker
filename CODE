// ðŸŸ¢ HABIT TRACKER CORE
// Version 2.0 - Authenticated & Architectural Overhaul

const FILE_NAME = "habit_tracker_data.json";
const KEYCHAIN_HABITS_KEY = "multiHabitTrackerHabits";
const KEYCHAIN_STORAGE_KEY = "multiHabitTrackerData";
const KEYCHAIN_THEME_KEY = "multiHabitTrackerTheme";

let fm;
try {
  fm = FileManager.iCloud();
} catch (e) {
  fm = FileManager.local();
}

// ðŸ”µ DEFAULT CONFIG
const DEFAULT_THEME = "dark";
const THEMES = {
  dark: { background: "#000000", text: "#ffffff" },
  light: { background: "#ffffff", text: "#454545" },
  midnight: { background: "#0D1B2A", text: "#E0E1DD" },
  solarized: { background: "#002B36", text: "#839496" },
  nordic: { background: "#2E3440", text: "#D8DEE9" },
  paper: { background: "#FDF6E3", text: "#586E75" },
  pink: { background: "#FFC0CB", text: "#8B5D68" }
};

const THEME_NAMES = [
  "Classic Dark", "Classic Light", "Midnight Blue",
  "Solarized Dark", "Nordic Night", "Paper White", "Sweet Pink"
];

const DEFAULT_HABIT_COLORS = [
  "#FF595E", "#FFCA3A", "#8AC926", "#1982C4", "#6A4C93", "#F15BB5"
];

// ðŸ”µ FILE SYSTEM MANAGEMENT
function getFilePath() {
  const dir = fm.documentsDirectory();
  return fm.joinPath(dir, FILE_NAME);
}

async function loadData() {
  const path = getFilePath();

  if (fm.fileExists(path)) {
    if (fm.isFileStoredIniCloud(path)) {
      await fm.downloadFileFromiCloud(path);
    }
    const json = fm.readString(path);
    return JSON.parse(json);
  } else {
    // Migration check
    return await migrateFromKeychain();
  }
}

function saveData(data) {
  const path = getFilePath();
  fm.writeString(path, JSON.stringify(data, null, 2));
}

async function migrateFromKeychain() {
  console.log("Checking for legacy Keychain data...");
  let habits = [];
  let settings = { theme: DEFAULT_THEME };

  // 1. Load Theme
  if (Keychain.contains(KEYCHAIN_THEME_KEY)) {
    const t = Keychain.get(KEYCHAIN_THEME_KEY);
    if (THEMES[t]) settings.theme = t;
  }

  // 2. Load Habits List
  let habitNames = [];
  if (Keychain.contains(KEYCHAIN_HABITS_KEY)) {
    try {
      habitNames = JSON.parse(Keychain.get(KEYCHAIN_HABITS_KEY));
    } catch (e) { console.error(e); }
  }

  // 3. Load History
  if (Keychain.contains(KEYCHAIN_STORAGE_KEY)) {
    try {
      const raw = Keychain.get(KEYCHAIN_STORAGE_KEY);
      const parsed = JSON.parse(raw); // { habits: { "Name": ["2023-01-01"] } }

      habitNames.forEach((name, index) => {
        const historyArray = parsed.habits[name] || [];

        // Convert array of dates string "2023-01-01" to map { "2023-01-01": 1 }
        let historyMap = {};
        historyArray.forEach(date => {
          historyMap[date] = 1;
        });

        habits.push({
          id: generateUUID(),
          name: name,
          icon: "circle.fill", // Default icon
          color: DEFAULT_HABIT_COLORS[index % DEFAULT_HABIT_COLORS.length],
          target: 1,
          history: historyMap
        });
      });

    } catch (e) { console.error("Migration error: " + e); }
  } else {
    // Initialize default if no old data
    habits = [
      { id: generateUUID(), name: "Water", icon: "drop.fill", color: "#64D2FF", target: 1, history: {} },
      { id: generateUUID(), name: "Read", icon: "book.fill", color: "#FFD60A", target: 1, history: {} }
    ];
  }

  const newData = { settings, habits };
  saveData(newData);
  return newData;
}

// ðŸ”µ HELPER FUNCTIONS
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function daysInMonth(month, year) {
  return new Date(year, month, 0).getDate(); // month is 1-indexed
}

function generateMonthDates(year, month) {
  const days = daysInMonth(month, year);
  const dates = [];
  for (let d = 1; d <= days; d++) {
    dates.push(`${year}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`);
  }
  return dates;
}

// ðŸ”µ WIDGET CREATION
function createWidget(data, widgetFamily) {
  const { settings, habits } = data;
  const theme = THEMES[settings.theme] || THEMES.dark;

  const w = new ListWidget();
  w.backgroundColor = new Color(theme.background);
  w.setPadding(12, 12, 12, 12);

  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth() + 1;
  const todayDate = `${year}-${String(month).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

  // Header: Weekday | Month
  const headerStack = w.addStack();
  headerStack.layoutHorizontally();
  headerStack.centerAlignContent();

  const weekday = headerStack.addText(now.toLocaleDateString("en-US", { weekday: "short" }).toUpperCase());
  weekday.font = Font.heavySystemFont(10);
  weekday.textColor = Color.red();

  headerStack.addSpacer(6);

  const dateText = headerStack.addText(`${now.getDate()} ${now.toLocaleDateString("en-US", { month: "short" }).toUpperCase()}`);
  dateText.font = Font.semiboldSystemFont(10);
  dateText.textColor = new Color(theme.text, 0.6);

  w.addSpacer(8);

  // Render Habits
  const maxHabits = 8; // Safety limit
  const habitsToShow = habits.slice(0, maxHabits);

  if (habitsToShow.length === 0) {
    const t = w.addText("No habits set.");
    t.textColor = new Color(theme.text);
    return w;
  }

  // Layout Logic
  // Scale row height based on number of habits to fill space
  const dates = generateMonthDates(year, month);

  habitsToShow.forEach(habit => {
    const row = w.addStack();
    row.layoutHorizontally();
    row.centerAlignContent();

    // Icon (Placeholder using Text for now, switch to SFSymbol later if needed or image)
    const icon = SFSymbol.named(habit.icon) || SFSymbol.named("circle.fill");
    const iconImg = row.addImage(icon.image);
    iconImg.imageSize = new Size(12, 12);
    iconImg.tintColor = new Color(habit.color);

    row.addSpacer(6);

    // Dots Grid
    // To fit all days, we might need logic. For now, standard row.
    const dotsStack = row.addStack();
    dotsStack.layoutHorizontally(); // Simple horizontal list for now

    // Calculate visible range (last 15 days or current month?)
    // Requirement: "Widget will load last 30 days... but only display number of days that fit"
    // For simplicity in Stage 1, we show current month dots like original, but upgrade logic

    // Let's stick to the grid idea: dates of this month
    // Determine circle size based on width availability? 
    // Simplified: Show up to N days back + today? 
    // The requirement says "The widget will load the last 30 days... but it will only display the number of days that fit"
    // Let's try to fit roughly 15-20 dots

    const visibleDates = dates; // Show all month for now

    visibleDates.forEach(date => {
      const count = habit.history[date] || 0;
      const target = habit.target || 1;
      const opacity = count > 0 ? Math.min(count / target, 1.0) : 0.2;

      // Highlight today
      const isToday = (date === todayDate);

      const dotStack = dotsStack.addStack();
      dotStack.layoutVertically();

      // Dot
      const dotSize = 6;
      const dot = dotStack.addText("â—"); // \u25CF
      dot.font = Font.systemFont(dotSize);

      let color = new Color(habit.color);
      if (count === 0) {
        color = new Color(theme.text, 0.2);
        if (isToday) color = Color.red(); // Highlight today empty
      } else {
        // Apply opacity to the habit color? Use constructor
        // Scriptable Color doesn't take opacity in constructor with hex, assumes 1.
        // We can mix or just use alpha on the color object
        // However, creating a new color from another is tricky.
        // Let's assume habit.color is hex.
        color = new Color(habit.color, opacity);
      }

      dot.textColor = color;
      dotStack.addSpacer(1);
    });

    row.addSpacer(null);

    // Count
    let monthCount = 0;
    Object.values(habit.history).forEach(v => monthCount += v);
    const countText = row.addText(`${monthCount}`);
    countText.font = Font.systemFont(10);
    countText.textColor = new Color(theme.text, 0.5);

    w.addSpacer(4);
  });

  return w;
}

// ðŸ”µ MAIN ENTRY
async function main() {
  const data = await loadData();

  if (config.runsInWidget) {
    const w = createWidget(data, config.widgetFamily);
    Script.setWidget(w);
  } else {
    // In-App Menu
    // For Stage 1 we just show the widget preview and migration success
    const w = createWidget(data, "medium");
    await w.presentMedium();
  }
}

await main();
Script.complete();
