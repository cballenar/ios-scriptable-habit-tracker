// ðŸŸ¢ HABIT TRACKER CORE

const FILE_NAME = "habit_tracker_data.json";
const KEYCHAIN_HABITS_KEY = "multiHabitTrackerHabits";
const KEYCHAIN_STORAGE_KEY = "multiHabitTrackerData";
const KEYCHAIN_THEME_KEY = "multiHabitTrackerTheme";

let fm;
try {
  fm = FileManager.iCloud();
} catch (e) {
  fm = FileManager.local();
}

// ðŸ”µ DEFAULT CONFIG
const DEFAULT_THEME = "dark";
const THEMES = {
  dark: { background: "#000000", text: "#ffffff" },
  light: { background: "#ffffff", text: "#454545" },
  midnight: { background: "#0D1B2A", text: "#E0E1DD" },
  solarized: { background: "#002B36", text: "#839496" },
  nordic: { background: "#2E3440", text: "#D8DEE9" },
  paper: { background: "#FDF6E3", text: "#586E75" },
  pink: { background: "#FFC0CB", text: "#8B5D68" }
};

const THEME_NAMES = [
  "Classic Dark", "Classic Light", "Midnight Blue",
  "Solarized Dark", "Nordic Night", "Paper White", "Sweet Pink"
];

const COLOR_PALETTE = [
  { name: "Coral Red", hex: "#FF595E" },
  { name: "Sunny Yellow", hex: "#FFCA3A" },
  { name: "Pear Green", hex: "#8AC926" },
  { name: "Ocean Blue", hex: "#1982C4" },
  { name: "Royal Purple", hex: "#6A4C93" },
  { name: "Hot Pink", hex: "#F15BB5" },
  { name: "Teal", hex: "#2dd4bf" },
  { name: "Sky Blue", hex: "#38bdf8" },
  { name: "Slate Gray", hex: "#64748b" }
];

const DEFAULT_HABIT_COLORS = COLOR_PALETTE.map(c => c.hex);

// ðŸ”µ FILE SYSTEM MANAGEMENT
function getFilePath() {
  const dir = fm.documentsDirectory();
  return fm.joinPath(dir, FILE_NAME);
}

async function loadData() {
  const path = getFilePath();

  if (fm.fileExists(path)) {
    if (fm.isFileStoredIniCloud(path)) {
      await fm.downloadFileFromiCloud(path);
    }
    const json = fm.readString(path);
    return JSON.parse(json);
  } else {
    return await migrateFromKeychain();
  }
}

function saveData(data) {
  const path = getFilePath();
  fm.writeString(path, JSON.stringify(data, null, 2));
}

async function migrateFromKeychain() {
  console.log("Checking for legacy Keychain data...");
  let habits = [];
  let settings = { theme: DEFAULT_THEME };

  if (Keychain.contains(KEYCHAIN_THEME_KEY)) {
    const t = Keychain.get(KEYCHAIN_THEME_KEY);
    if (THEMES[t]) settings.theme = t;
  }

  let habitNames = [];
  if (Keychain.contains(KEYCHAIN_HABITS_KEY)) {
    try {
      habitNames = JSON.parse(Keychain.get(KEYCHAIN_HABITS_KEY));
    } catch (e) { console.error(e); }
  }

  if (Keychain.contains(KEYCHAIN_STORAGE_KEY)) {
    try {
      const raw = Keychain.get(KEYCHAIN_STORAGE_KEY);
      const parsed = JSON.parse(raw);

      habitNames.forEach((name, index) => {
        const historyArray = parsed.habits[name] || [];
        let historyMap = {};
        historyArray.forEach(date => { historyMap[date] = 1; });

        habits.push({
          id: generateUUID(),
          name: name,
          icon: "circle.fill", // Default icon
          color: DEFAULT_HABIT_COLORS[index % DEFAULT_HABIT_COLORS.length],
          target: 1,
          history: historyMap
        });
      });

    } catch (e) { console.error("Migration error: " + e); }
  } else {
    habits = [
      { id: generateUUID(), name: "Water", icon: "drop.fill", color: "#64D2FF", target: 1, history: {} },
      { id: generateUUID(), name: "Read", icon: "book.fill", color: "#FFD60A", target: 1, history: {} }
    ];
  }

  const newData = { settings, habits };
  saveData(newData);
  return newData;
}

// ðŸ”µ HELPER FUNCTIONS
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}



// ðŸ”µ UI: WIDGET RENDERING
function createWidget(data, widgetFamily) {
  const { settings, habits } = data;
  const theme = THEMES[settings.theme] || THEMES.dark;

  const w = new ListWidget();
  w.backgroundColor = new Color(theme.background);
  w.setPadding(12, 0, 12, 0);

  // Config
  const ICON_SIZE = new Size(21, 21);
  const DOT_SIZE = new Size(21, 21);
  const DOT_SPACING = 0;
  const ROW_SPACING = 0;
  let COLUMNS = 14; // Fixed width 14 days

  // Adaptive Logic
  if (widgetFamily === "small") COLUMNS = 5;

  const count = habits.length;
  let maxHabitsToShow = 6;
  let rowsPerHabit = 1;
  let laneSpacing = 4;

  if (widgetFamily === "large") {
    maxHabitsToShow = 12;
    // Default spacing for large widget
    laneSpacing = 4;

    switch (count) {
      case 1: rowsPerHabit = 14; laneSpacing = 0; break;
      case 2: rowsPerHabit = 7; laneSpacing = 16; break;
      case 3: rowsPerHabit = 4; laneSpacing = 12; break;
      case 4: rowsPerHabit = 3; laneSpacing = 12; break;
      case 5:
      case 6: rowsPerHabit = 2; laneSpacing = 8; break;
      default: rowsPerHabit = 1; laneSpacing = 4; break;
    }
  } else {
    // Small & Medium Logic
    laneSpacing = (count > 5) ? 2 : 4;

    switch (count) {
      case 1: rowsPerHabit = 7; laneSpacing = 0; break;
      case 2: rowsPerHabit = 3; laneSpacing = 4; break;
      case 3: rowsPerHabit = 2; laneSpacing = 2; break;
      default: rowsPerHabit = 1; break;
    }
  }

  const habitsToShow = habits.slice(0, maxHabitsToShow);

  if (habitsToShow.length === 0) {
    const t = w.addText("No habits set.");
    t.textColor = new Color(theme.text);
    return w;
  }

  // Pre-load Symbols
  const dotSymbol = SFSymbol.named("square.fill");

  // Vertically Center Content
  w.addSpacer();

  habitsToShow.forEach((habit, index) => {
    // LANE (Horizontal: Icon + Grid)
    const lane = w.addStack();
    lane.layoutHorizontally();
    lane.centerAlignContent(); // Vertically center icon relative to grid

    // 1. Spacer Left
    lane.addSpacer();

    // 2. Icon (Centered in Lane)
    const iconFn = SFSymbol.named(habit.icon) || SFSymbol.named("circle.fill");
    const iconImg = lane.addImage(iconFn.image);
    iconImg.imageSize = ICON_SIZE;
    iconImg.tintColor = new Color(habit.color);

    // Tap to Increment
    const scriptName = Script.name();
    const url = `scriptable:///run/${encodeURIComponent(scriptName)}?habitName=${encodeURIComponent(habit.name)}&action=increment`;
    iconImg.url = url;

    lane.addSpacer(2); // Spacing between Icon and Grid

    // 3. Grid Stack (Vertical: Holds multiple rows of dots)
    const gridStack = lane.addStack();
    gridStack.layoutVertically();

    // Render Rows (History)
    for (let r = 0; r < rowsPerHabit; r++) {
      const rowStack = gridStack.addStack();
      rowStack.layoutHorizontally();

      const rowOffsetDays = r * COLUMNS;

      // Generate dots for this row
      for (let c = COLUMNS - 1; c >= 0; c--) {
        const dayOffset = rowOffsetDays + c;

        const d = new Date();
        d.setDate(d.getDate() - dayOffset);
        const dateStr = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;

        // Get Data
        const count = habit.history[dateStr] || 0;
        const target = habit.target || 1;
        const opacity = count > 0 ? Math.min(count / target, 1.0) : 0.15;
        const isToday = (dayOffset === 0);

        const dotImg = rowStack.addImage(dotSymbol.image);
        dotImg.imageSize = DOT_SIZE;

        let color;
        if (count === 0) {
          if (isToday) {
            color = new Color(theme.text, 0.6);
          } else if (d.getDay() === 0) { // Sunday highlight
            color = new Color(theme.text, 0.35); // Lighter than normal
          } else {
            color = new Color(theme.text, 0.2);
          }
        } else {
          color = new Color(habit.color, opacity);
        }
        dotImg.tintColor = color;

        if (c > 0) rowStack.addSpacer(DOT_SPACING);
      }

      if (r < rowsPerHabit - 1) gridStack.addSpacer(ROW_SPACING);
    }

    // 4. Spacer Right
    lane.addSpacer(); // Centers the block

    if (index < habitsToShow.length - 1) w.addSpacer(laneSpacing);
  });

  // Vertically Center Content
  w.addSpacer();

  return w;
}

// ðŸ”µ UI: ADMIN TOOLS
async function presentMainMenu(data) {
  const alert = new Alert();
  alert.title = "Habit Tracker Options";
  alert.addAction("Manage Habits");
  alert.addAction("Set Theme");
  alert.addCancelAction("Exit");

  const response = await alert.presentSheet();

  if (response === 0) {
    await presentHabitManager(data);
  } else if (response === 1) {
    await presentThemePicker(data);
    await presentMainMenu(data);
  }
}

async function presentHabitManager(data) {
  const table = new UITable();
  table.showSeparators = true;

  // Header (Pseudo-header to allow dismissOnSelect)
  const navRow = new UITableRow();
  navRow.height = 60;
  navRow.dismissOnSelect = true; // Essential for refreshing the table without stacking

  // Title
  const titleCell = navRow.addText("Manage Habits");
  titleCell.titleFont = Font.mediumSystemFont(22);
  titleCell.widthWeight = 10;

  // Add "+" Action
  const plusIcon = SFSymbol.named("plus");
  const addCell = navRow.addImage(plusIcon.image);
  addCell.widthWeight = 1;
  addCell.rightAligned();

  // Entire row triggers the action to support dismissal
  navRow.onSelect = async () => {
    await presentHabitForm(data);
    await presentHabitManager(data);
  }
  table.addRow(navRow);

  // Existing Habits
  data.habits.forEach((habit, index) => {
    const row = new UITableRow();
    row.height = 60;
    row.dismissOnSelect = true;
    row.cellSpacing = 12;

    // Icon
    const iconFn = SFSymbol.named(habit.icon) || SFSymbol.named("circle.fill");
    const imageCell = row.addImage(iconFn.image);
    imageCell.widthWeight = 1;
    imageCell.tintColor = new Color(habit.color);

    // Info
    const textCell = row.addText(habit.name, `Target: ${habit.target} | Color: ${habit.color}`);
    textCell.widthWeight = 8;
    textCell.titleFont = Font.systemFont(16);
    textCell.subtitleFont = Font.systemFont(12);
    textCell.subtitleColor = Color.gray();

    // Edit Action
    row.onSelect = async () => {
      await presentHabitActionSheet(data, habit, index);
      await presentHabitManager(data);
    };

    table.addRow(row);
  });

  await table.present();
}

async function presentThemePicker(data) {
  const a = new Alert();
  a.title = "Select Theme";
  THEME_NAMES.forEach(name => a.addAction(name));
  a.addCancelAction("Cancel");

  const choice = await a.presentSheet();
  if (choice >= 0 && choice < THEME_NAMES.length) {
    const keys = Object.keys(THEMES);
    if (choice < keys.length) {
      data.settings.theme = keys[choice];
      saveData(data);
    }
  }
}

async function presentHabitActionSheet(data, habit, index) {
  const a = new Alert();
  a.title = habit.name;
  a.message = "Choose an action";
  a.addAction("Edit Details");
  a.addAction("Manual Entry");
  a.addDestructiveAction("Delete Habit");
  a.addCancelAction("Cancel");

  const choice = await a.presentSheet();
  if (choice === 0) {
    await presentHabitForm(data, habit, index);
  } else if (choice === 1) {
    await presentManualEntry(data, habit);
  } else if (choice === 2) {
    if (await confirmDelete(habit.name)) {
      data.habits.splice(index, 1);
      saveData(data);
    }
  }
}

async function presentManualEntry(data, habit) {
  // 1. Pick Date
  try {
    const picker = new DatePicker();
    picker.initialDate = new Date();
    const date = await picker.pickDate();

    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

    // 2. Get Current Value
    const currentVal = habit.history[dateStr] || 0;

    // 3. Prompt for new value
    const alert = new Alert();
    alert.title = `Set value for ${dateStr}`;
    alert.message = `Current value: ${currentVal}`;
    alert.addTextField("Count", String(currentVal));
    alert.addAction("Save");
    alert.addDestructiveAction("Clear Entry");
    alert.addCancelAction("Cancel");

    const response = await alert.presentAlert();

    if (response === 0) { // Save
      const input = alert.textFieldValue(0);
      const val = parseInt(input);
      if (!isNaN(val) && val > 0) {
        habit.history[dateStr] = val;
      } else {
        delete habit.history[dateStr];
      }
      saveData(data);
      const n = new Notification();
      n.title = "Entry Saved";
      n.body = `${habit.name} on ${dateStr}: ${val || 0}`;
      n.schedule();

    } else if (response === 1) { // Clear
      delete habit.history[dateStr];
      saveData(data);
    }

  } catch (e) {
    // Picker cancelled or error
  }
}

async function confirmDelete(name) {
  const a = new Alert();
  a.title = `Delete ${name}?`;
  a.message = "This cannot be undone.";
  a.addDestructiveAction("Delete");
  a.addCancelAction("Cancel");
  return (await a.presentAlert()) === 0;
}

async function presentHabitForm(data, habit = null, index = null) {
  const isEdit = habit !== null;
  // Initialize working state
  let draft = isEdit ? { ...habit } : {
    id: generateUUID(),
    name: "",
    icon: "star.fill",
    color: COLOR_PALETTE[0].hex,
    target: 1,
    history: {}
  };

  // Helper to re-render table
  const table = new UITable();
  table.showSeparators = true;

  const render = () => {
    table.removeAllRows();

    // TITLE ROW
    const titleRow = new UITableRow();
    titleRow.isHeader = true;
    titleRow.addText(isEdit ? "Edit Habit" : "New Habit");
    table.addRow(titleRow);

    // 1. NAME
    const nameRow = new UITableRow();
    nameRow.height = 60;
    nameRow.dismissOnSelect = false; 
    
    const nameLabel = nameRow.addText("Name");
    nameLabel.widthWeight = 3;  // Fixed Label Width
    
    const nameVal = nameRow.addText(draft.name || "Habit name...");
    nameVal.widthWeight = 7;
    nameVal.leftAligned();
    nameVal.titleColor = Color.gray();
    
    nameRow.onSelect = async () => {
      const a = new Alert();
      a.title = "Habit Name";
      a.addTextField("Name", draft.name);
      a.addAction("OK");
      a.addCancelAction("Cancel");
      if (await a.presentAlert() === 0) {
        draft.name = a.textFieldValue(0).trim();
        render(); 
      }
    };
    table.addRow(nameRow);

    // 2. ICON
    const iconRow = new UITableRow();
    iconRow.height = 60;
    iconRow.dismissOnSelect = false; 
    
    const iconLabel = iconRow.addText("Icon");
    iconLabel.widthWeight = 3; 

    const iconVal = iconRow.addText(draft.icon);
    iconVal.widthWeight = 6;
    iconVal.leftAligned();
    iconVal.titleColor = Color.gray();
    
    const iconImg = SFSymbol.named(draft.icon) || SFSymbol.named("questionmark.circle");
    const iconCell = iconRow.addImage(iconImg.image);
    iconCell.widthWeight = 1;
    iconCell.rightAligned();
    // Ensure visibility in both modes
    iconCell.tintColor = Color.dynamic(new Color("000000"), new Color("ffffff"));
    
    iconRow.onSelect = async () => {
      const a = new Alert();
      a.title = "SFSymbol Name";
      a.message = "Enter any valid SFSymbol name";
      a.addTextField("Symbol", draft.icon);
      a.addAction("OK");
      a.addCancelAction("Cancel");
      if (await a.presentAlert() === 0) {
        draft.icon = a.textFieldValue(0).trim();
        render();
      }
    };
    table.addRow(iconRow);

    // 3. COLOR
    const colorRow = new UITableRow();
    colorRow.height = 60;
    colorRow.dismissOnSelect = false;
    
    const colorLabel = colorRow.addText("Color");
    colorLabel.widthWeight = 3;
    
    const knownColor = COLOR_PALETTE.find(c => c.hex.toLowerCase() === draft.color.toLowerCase());
    const colorVal = colorRow.addText(knownColor ? knownColor.name : draft.color);
    colorVal.widthWeight = 6;
    colorVal.leftAligned();
    colorVal.titleColor = Color.gray();

    // Draw Color Circle (High Res)
    const drawColor = new DrawContext();
    drawColor.size = new Size(72, 72); 
    drawColor.setFillColor(new Color(draft.color));
    drawColor.fillEllipse(new Rect(0, 0, 72, 72));
    const swatchCell = colorRow.addImage(drawColor.getImage());
    swatchCell.widthWeight = 1;
    swatchCell.rightAligned();
    
    colorRow.onSelect = async () => {
      const p = new Alert();
      p.title = "Select Color";
      COLOR_PALETTE.forEach(c => p.addAction(c.name));
      p.addAction("Custom Hex...");
      p.addCancelAction("Cancel");
      
      const sel = await p.presentSheet();
      if (sel >= 0 && sel < COLOR_PALETTE.length) {
        draft.color = COLOR_PALETTE[sel].hex;
      } else if (sel === COLOR_PALETTE.length) {
         const a = new Alert();
         a.title = "Hex Color";
         a.addTextField("#RRGGBB", draft.color);
         a.addAction("Set");
         a.addCancelAction("Cancel");
         if (await a.presentAlert() === 0) {
             draft.color = a.textFieldValue(0).trim();
         }
      }
      render();
    };
    table.addRow(colorRow);

    // 4. TARGET
    const targetRow = new UITableRow();
    targetRow.height = 60;
    targetRow.dismissOnSelect = false; 
    
    const targetLabel = targetRow.addText("Daily Target");
    targetLabel.widthWeight = 3;

    const targetVal = targetRow.addText(`${draft.target}`);
    targetVal.widthWeight = 7;
    targetVal.leftAligned();
    targetVal.titleColor = Color.gray();
    
    targetRow.onSelect = async () => {
       const a = new Alert();
       a.title = "Daily Goal";
       a.addTextField("Count", String(draft.target));
       a.addAction("OK");
       if (await a.presentAlert() === 0) {
           draft.target = parseInt(a.textFieldValue(0)) || 1;
           render();
       }
    };
    table.addRow(targetRow);

    // SAVE BUTTON
    const saveRow = new UITableRow();
    saveRow.height = 60;
    saveRow.dismissOnSelect = true; // Close form on save
    const saveText = saveRow.addText("Save Habit");
    saveText.titleColor = Color.blue();
    saveText.centerAligned();
    saveRow.onSelect = () => {
       if (draft.name.length === 0) {
           const err = new Alert();
           err.message = "Please enter a habit name.";
           err.addAction("OK");
           err.present();
           return;
       }
       
       // Commit
       if (isEdit) {
           data.habits[index] = draft;
       } else {
           data.habits.push(draft);
       }
       saveData(data);
       // We can't easily "dismiss" a presented table via code in standard Scriptable 
       // nicely without a refresh, but in this flow we typically just fall back 
       // to the Manager which reloads.
       // Ideally we show a confirmation?
       const n = new Notification();
       n.title = "Saved";
       n.schedule(); 
    };
    table.addRow(saveRow);
    
    table.reload();
  };

  render();
  await table.present();
}

// ðŸ”µ MAIN ENTRY
async function main() {
  const data = await loadData();

  // Handle URL Scheme
  if (args.queryParameters["action"] === "increment") {
    // Case A: ID provided (Widget)
    if (args.queryParameters["habitId"]) {
      await incrementHabit(data, args.queryParameters["habitId"]);
      return;
    }

    // Case B: Name provided (Shortcut URL)
    if (args.queryParameters["habitName"]) {
      const name = args.queryParameters["habitName"];
      const habit = data.habits.find(h => h.name.toLowerCase() === name.toLowerCase());
      if (habit) {
        await incrementHabit(data, habit.id);
      } else {
        const n = new Notification();
        n.title = "Habit Not Found";
        n.body = `Could not find habit named '${name}'`;
        n.schedule();
      }
      return;
    }
  }

  // Handle Shortcut Input
  if (args.shortcutParameter) {
    let param = args.shortcutParameter;
    let habitName = null;

    // Check if valid JSON object or simple string
    if (typeof param === "string") {
      habitName = param;
    } else if (typeof param === "object" && param.name) {
      habitName = param.name;
    }

    if (habitName) {
      // Find by name
      const habit = data.habits.find(h => h.name.toLowerCase() === habitName.toLowerCase());
      if (habit) {
        await incrementHabit(data, habit.id);
      } else {
        const n = new Notification();
        n.title = "Habit Not Found";
        n.body = `Could not find habit named '${habitName}'`;
        n.schedule();
      }
    }
    return;
  }

  // Run UI
  if (config.runsInWidget) {
    const w = createWidget(data, config.widgetFamily);
    Script.setWidget(w);
  } else {
    // In-App Dashboard
    await presentMainMenu(data);
  }
}

async function incrementHabit(data, habitId) {
  const habitIndex = data.habits.findIndex(h => h.id === habitId);
  if (habitIndex === -1) return;

  const now = new Date();
  const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

  // Update Data
  const habit = data.habits[habitIndex];
  habit.history[dateStr] = (habit.history[dateStr] || 0) + 1;
  saveData(data);

  // Subtle feedback only
  try { Device.vibrate(); } catch (e) { }
}

await main();
Script.complete();
