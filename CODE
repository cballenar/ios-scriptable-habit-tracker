// ðŸŸ¢ HABIT TRACKER CORE
// Version 2.1

const FILE_NAME = "habit_tracker_data.json";
const KEYCHAIN_HABITS_KEY = "multiHabitTrackerHabits";
const KEYCHAIN_STORAGE_KEY = "multiHabitTrackerData";
const KEYCHAIN_THEME_KEY = "multiHabitTrackerTheme";

let fm;
try {
  fm = FileManager.iCloud();
} catch (e) {
  fm = FileManager.local();
}

// ðŸ”µ DEFAULT CONFIG
const DEFAULT_THEME = "dark";
const THEMES = {
  dark: { background: "#000000", text: "#ffffff" },
  light: { background: "#ffffff", text: "#454545" },
  midnight: { background: "#0D1B2A", text: "#E0E1DD" },
  solarized: { background: "#002B36", text: "#839496" },
  nordic: { background: "#2E3440", text: "#D8DEE9" },
  paper: { background: "#FDF6E3", text: "#586E75" },
  pink: { background: "#FFC0CB", text: "#8B5D68" }
};

const THEME_NAMES = [
  "Classic Dark", "Classic Light", "Midnight Blue",
  "Solarized Dark", "Nordic Night", "Paper White", "Sweet Pink"
];

const DEFAULT_HABIT_COLORS = [
  "#FF595E", "#FFCA3A", "#8AC926", "#1982C4", "#6A4C93", "#F15BB5"
];

// ðŸ”µ FILE SYSTEM MANAGEMENT
function getFilePath() {
  const dir = fm.documentsDirectory();
  return fm.joinPath(dir, FILE_NAME);
}

async function loadData() {
  const path = getFilePath();

  if (fm.fileExists(path)) {
    if (fm.isFileStoredIniCloud(path)) {
      await fm.downloadFileFromiCloud(path);
    }
    const json = fm.readString(path);
    return JSON.parse(json);
  } else {
    return await migrateFromKeychain();
  }
}

function saveData(data) {
  const path = getFilePath();
  fm.writeString(path, JSON.stringify(data, null, 2));
}

async function migrateFromKeychain() {
  console.log("Checking for legacy Keychain data...");
  let habits = [];
  let settings = { theme: DEFAULT_THEME };

  if (Keychain.contains(KEYCHAIN_THEME_KEY)) {
    const t = Keychain.get(KEYCHAIN_THEME_KEY);
    if (THEMES[t]) settings.theme = t;
  }

  let habitNames = [];
  if (Keychain.contains(KEYCHAIN_HABITS_KEY)) {
    try {
      habitNames = JSON.parse(Keychain.get(KEYCHAIN_HABITS_KEY));
    } catch (e) { console.error(e); }
  }

  if (Keychain.contains(KEYCHAIN_STORAGE_KEY)) {
    try {
      const raw = Keychain.get(KEYCHAIN_STORAGE_KEY);
      const parsed = JSON.parse(raw);

      habitNames.forEach((name, index) => {
        const historyArray = parsed.habits[name] || [];
        let historyMap = {};
        historyArray.forEach(date => { historyMap[date] = 1; });

        habits.push({
          id: generateUUID(),
          name: name,
          icon: "circle.fill", // Default icon
          color: DEFAULT_HABIT_COLORS[index % DEFAULT_HABIT_COLORS.length],
          target: 1,
          history: historyMap
        });
      });

    } catch (e) { console.error("Migration error: " + e); }
  } else {
    habits = [
      { id: generateUUID(), name: "Water", icon: "drop.fill", color: "#64D2FF", target: 1, history: {} },
      { id: generateUUID(), name: "Read", icon: "book.fill", color: "#FFD60A", target: 1, history: {} }
    ];
  }

  const newData = { settings, habits };
  saveData(newData);
  return newData;
}

// ðŸ”µ HELPER FUNCTIONS
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function daysInMonth(month, year) {
  return new Date(year, month, 0).getDate();
}

function generateMonthDates(year, month) {
  const days = daysInMonth(month, year);
  const dates = [];
  for (let d = 1; d <= days; d++) {
    dates.push(`${year}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`);
  }
  return dates;
}

// ðŸ”µ UI: WIDGET RENDERING
function createWidget(data, widgetFamily) {
  const { settings, habits } = data;
  const theme = THEMES[settings.theme] || THEMES.dark;

  const w = new ListWidget();
  w.backgroundColor = new Color(theme.background);
  // Reduced padding to allow centering spacers to do the work
  w.setPadding(12, 0, 12, 0);

  // Layout Configuration
  // Max habits based on widget height constraints
  const MAX_HABITS = widgetFamily === "small" ? 4 : 5;
  // Increased days to fill width
  const DAYS_TO_SHOW = widgetFamily === "small" ? 5 : 14;

  const ICON_SIZE = new Size(22, 22);
  const DOT_SIZE = new Size(22, 22);
  const DOT_SPACING = 0;
  const ROW_SPACING = 0;

  // Render Habits
  const habitsToShow = habits.slice(0, MAX_HABITS);

  if (habitsToShow.length === 0) {
    const t = w.addText("No habits set.");
    t.textColor = new Color(theme.text);
    return w;
  }

  // Generate Trailing Dates
  const now = new Date();
  const dates = [];
  for (let i = DAYS_TO_SHOW - 1; i >= 0; i--) {
    const d = new Date();
    d.setDate(now.getDate() - i);
    const dateStr = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    dates.push(dateStr);
  }
  const todayDate = dates[dates.length - 1];

  // Pre-load Dot Symbol for efficiency
  const dotSymbol = SFSymbol.named("square.fill");

  habitsToShow.forEach(habit => {
    const row = w.addStack();
    row.layoutHorizontally();
    row.centerAlignContent();

    // Centering Spacer (Left)
    row.addSpacer();

    // Icon
    const iconFn = SFSymbol.named(habit.icon) || SFSymbol.named("circle.fill");
    const iconImg = row.addImage(iconFn.image);
    iconImg.imageSize = ICON_SIZE;
    iconImg.tintColor = new Color(habit.color);

    // Spacing between Icon and Grid
    row.addSpacer(2);

    // Dots Grid
    const dotsStack = row.addStack();
    dotsStack.layoutHorizontally();
    dotsStack.centerAlignContent();

    dates.forEach(date => {
      const count = habit.history[date] || 0;
      const target = habit.target || 1;
      const opacity = count > 0 ? Math.min(count / target, 1.0) : 0.15;
      const isToday = (date === todayDate);

      // Dot Image
      const dotImg = dotsStack.addImage(dotSymbol.image);
      dotImg.imageSize = DOT_SIZE;

      let color;
      if (count === 0) {
        color = new Color(theme.text, 0.2);
        if (isToday) color = new Color(theme.text, 0.6); // Highlight today
      } else {
        color = new Color(habit.color, opacity);
      }
      dotImg.tintColor = color;

      dotsStack.addSpacer(DOT_SPACING);
    });

    // Centering Spacer (Right)
    row.addSpacer();

    w.addSpacer(ROW_SPACING);
  });

  return w;
}

// ðŸ”µ UI: ADMIN TOOLS
async function presentMainMenu(data) {
  const alert = new Alert();
  alert.title = "Habit Tracker Options";
  alert.addAction("Manage Habits");
  alert.addAction("Set Theme");
  alert.addCancelAction("Exit");

  const response = await alert.presentSheet();

  if (response === 0) {
    await presentHabitManager(data);
  } else if (response === 1) {
    await presentThemePicker(data);
    await presentMainMenu(data);
  }
}

async function presentHabitManager(data) {
  const table = new UITable();
  table.showSeparators = true;

  // Header (Pseudo-header to allow dismissOnSelect)
  const navRow = new UITableRow();
  navRow.height = 60;
  navRow.dismissOnSelect = true; // Essential for refreshing the table without stacking

  // Title
  const titleCell = navRow.addText("Manage Habits");
  titleCell.titleFont = Font.mediumSystemFont(22);
  titleCell.widthWeight = 10;

  // Add "+" Action
  const plusIcon = SFSymbol.named("plus");
  const addCell = navRow.addImage(plusIcon.image);
  addCell.widthWeight = 1;
  addCell.rightAligned();

  // Entire row triggers the action to support dismissal
  navRow.onSelect = async () => {
    await presentHabitForm(data);
    await presentHabitManager(data);
  }
  table.addRow(navRow);

  // Existing Habits
  data.habits.forEach((habit, index) => {
    const row = new UITableRow();
    row.height = 60;
    row.dismissOnSelect = true;
    row.cellSpacing = 12;

    // Icon
    const iconFn = SFSymbol.named(habit.icon) || SFSymbol.named("circle.fill");
    const imageCell = row.addImage(iconFn.image);
    imageCell.widthWeight = 1;
    imageCell.tintColor = new Color(habit.color);

    // Info
    const textCell = row.addText(habit.name, `Target: ${habit.target} | Color: ${habit.color}`);
    textCell.widthWeight = 8;
    textCell.titleFont = Font.systemFont(16);
    textCell.subtitleFont = Font.systemFont(12);
    textCell.subtitleColor = Color.gray();

    // Edit Action
    row.onSelect = async () => {
      await presentHabitActionSheet(data, habit, index);
      await presentHabitManager(data);
    };

    table.addRow(row);
  });

  await table.present();
}

async function presentThemePicker(data) {
  const a = new Alert();
  a.title = "Select Theme";
  THEME_NAMES.forEach(name => a.addAction(name));
  a.addCancelAction("Cancel");

  const choice = await a.presentSheet();
  if (choice >= 0 && choice < THEME_NAMES.length) {
    const keys = Object.keys(THEMES);
    if (choice < keys.length) {
      data.settings.theme = keys[choice];
      saveData(data);
    }
  }
}

async function presentHabitActionSheet(data, habit, index) {
  const a = new Alert();
  a.title = habit.name;
  a.message = "Choose an action";
  a.addAction("Edit Details");
  a.addAction("Check-in (Implement Later)"); // Placeholder for check-in
  a.addDestructiveAction("Delete Habit");
  a.addCancelAction("Cancel");

  const choice = await a.presentSheet();
  if (choice === 0) {
    await presentHabitForm(data, habit, index);
  } else if (choice === 2) {
    if (await confirmDelete(habit.name)) {
      data.habits.splice(index, 1);
      saveData(data);
    }
  }
}

async function confirmDelete(name) {
  const a = new Alert();
  a.title = `Delete ${name}?`;
  a.message = "This cannot be undone.";
  a.addDestructiveAction("Delete");
  a.addCancelAction("Cancel");
  return (await a.presentAlert()) === 0;
}

async function presentHabitForm(data, habit = null, index = null) {
  const isEdit = habit !== null;
  const alert = new Alert();
  alert.title = isEdit ? "Edit Habit" : "New Habit";

  alert.addTextField("Name", isEdit ? habit.name : "");
  alert.addTextField("Icon (SFSymbol)", isEdit ? habit.icon : "star.fill");
  alert.addTextField("Color (Hex)", isEdit ? habit.color : DEFAULT_HABIT_COLORS[data.habits.length % DEFAULT_HABIT_COLORS.length]);
  alert.addTextField("Target (Daily)", isEdit ? String(habit.target) : "1");

  alert.addAction("Save");
  alert.addCancelAction("Cancel");

  const response = await alert.presentAlert();

  if (response === 0) {
    const name = alert.textFieldValue(0).trim();
    const icon = alert.textFieldValue(1).trim();
    const color = alert.textFieldValue(2).trim();
    const target = parseInt(alert.textFieldValue(3).trim()) || 1;

    if (name.length === 0) return; // Validation

    const newHabit = {
      id: isEdit ? habit.id : generateUUID(),
      name: name,
      icon: icon,
      color: color,
      target: target,
      history: isEdit ? habit.history : {}
    };

    if (isEdit) {
      data.habits[index] = newHabit;
    } else {
      data.habits.push(newHabit);
    }

    saveData(data);
  }
}

// ðŸ”µ MAIN ENTRY
async function main() {
  const data = await loadData();

  if (config.runsInWidget) {
    const w = createWidget(data, config.widgetFamily);
    Script.setWidget(w);
  } else {
    // In-App Dashboard
    await presentMainMenu(data);
  }
}

await main();
Script.complete();
