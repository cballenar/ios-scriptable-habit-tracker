// ðŸŸ¢ HABIT TRACKER CONFIGURATION
/**
 * HOW TO USE TAP-TO-TRACK:
 * 1. Add this script as a widget to your home screen.
 * 2. Tapping any habit lane will increment its count for today.
 * 3. URL Scheme Format: scriptable:///run/[ScriptName]?habitId=[ID]&action=increment
 *
 * ADMIN & MANUAL EDITS:
 * - Run the script inside the Scriptable app to access the Admin Menu.
 * - Manage Habits: Add/Edit/Delete habits with permanent labels.
 * - Manual Entry: Correct counts for any date using a Date Picker.
 * - Export Data: Backup your JSON data via the Share sheet.
 */

const fm = FileManager.iCloud();
const directory = fm.documentsDirectory();
const DATA_PATH = fm.joinPath(directory, "habit-tracker.json");

// Constants
const THEME_KEY = "multiHabitTrackerTheme";

// ðŸ”µ URL SCHEME HANDLER
if (args.queryParameters.habitId) {
  const data = loadData();
  const habitId = args.queryParameters.habitId;
  const action = args.queryParameters.action;

  if (action === "increment") {
    const today = formatDate(new Date());
    const habit = data.habits.find(h => h.id === habitId);
    if (habit) {
      if (!habit.history) habit.history = {};
      habit.history[today] = (habit.history[today] || 0) + 1;
      saveData(data);
    }
  }

  Safari.open("scriptable:///run/" + encodeURIComponent(Script.name()));
  Script.complete();
}

const THEMES = {
  dark: { background: "#000000", text: "#ffffff" },
  light: { background: "#ffffff", text: "#454545" }, // alterado aqui
  midnight: { background: "#0D1B2A", text: "#E0E1DD" },
  solarized: { background: "#002B36", text: "#839496" },
  nordic: { background: "#2E3440", text: "#D8DEE9" },
  paper: { background: "#FDF6E3", text: "#586E75" },
  pink: { background: "#FFC0CB", text: "#8B5D68" }
};

const THEME_NAMES = [
  "Classic Dark",
  "Classic Light",
  "Midnight Blue",
  "Solarized Dark",
  "Nordic Night",
  "Paper White",
  "Sweet Pink"
];

// Default Appearance
let COLOR_FILLED = new Color("#ffffff");
let BACKGROUND_COLOR = new Color("#000000");

const MENLO_REGULAR = new Font("Menlo", 8);
const PADDING = 16;
const LINES_SPACING = 6;

// ðŸ”µ THEME MANAGEMENT
function applyTheme(themeKey) {
  const theme = THEMES[themeKey] || THEMES.dark;
  BACKGROUND_COLOR = new Color(theme.background);
  COLOR_FILLED = new Color(theme.text);
}

function loadTheme() {
  try {
    const savedTheme = Keychain.get(THEME_KEY);
    if (savedTheme && THEMES[savedTheme]) {
      applyTheme(savedTheme);
    } else {
      applyTheme("dark");
      Keychain.set(THEME_KEY, "dark");
    }
  } catch (e) {
    console.log("Error loading theme: " + e);
    applyTheme("dark");
  }
}

async function selectTheme() {
  const alert = new Alert();
  alert.title = "Select Theme";
  THEME_NAMES.forEach(name => alert.addAction(name));
  alert.addCancelAction("Cancel");

  const selected = await alert.presentSheet();
  const themeKeys = Object.keys(THEMES);

  if (selected >= 0 && selected < themeKeys.length) {
    const themeKey = themeKeys[selected];
    Keychain.set(THEME_KEY, themeKey);
    applyTheme(themeKey);
    return true;
  }
  return false;
}

// ðŸ”µ DATA MANAGEMENT
function loadData() {
  if (fm.fileExists(DATA_PATH)) {
    try {
      if (!fm.isFileDownloaded(DATA_PATH)) {
        fm.downloadFileFromiCloud(DATA_PATH);
      }
      const raw = fm.readString(DATA_PATH);
      return JSON.parse(raw);
    } catch (e) {
      console.log("Error loading data from iCloud: " + e);
    }
  }
  return initializeData();
}

function saveData(data) {
  fm.writeString(DATA_PATH, JSON.stringify(data, null, 2));
}

function initializeData() {
  const data = {
    habits: [
      { id: "coffee", name: "Coffee", icon: "cup.and.saucer.fill", color: "#6F4E37", target: 4, history: {} },
      { id: "code", name: "Coding", icon: "terminal.fill", color: "#00FF00", target: 5, history: {} }
    ]
  };
  saveData(data);
  return data;
}

// ðŸ”µ HELPER FUNCTIONS
function formatDate(date) {
  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;
}

// ðŸ”µ UI FUNCTIONS
async function manageHabits(data) {
  const alert = new Alert();
  alert.title = "Manage Habits";
  data.habits.forEach(h => alert.addAction(h.name));
  alert.addAction("âž• Add New Habit");
  alert.addCancelAction("Back");

  const idx = await alert.presentSheet();
  if (idx === -1) return;

  if (idx === data.habits.length) {
    await editHabit(data, null);
  } else {
    await editHabit(data, data.habits[idx]);
  }
}

async function editHabit(data, habit) {
  const isNew = !habit;
  let current = habit ? { ...habit } : { id: "", name: "", icon: "star.fill", color: "#ffffff", target: 1, history: {} };

  const table = new UITable();
  table.showSeparators = false;

  async function render() {
    table.removeAllRows();

    const header = new UITableRow();
    header.isHeader = true;
    const headerCell = header.addText(isNew ? "Add New Habit" : `Editing ${current.name}`);
    headerCell.titleFont = Font.boldSystemFont(18);
    table.addRow(header);

    const fields = [
      { label: "ID (unique)", key: "id", value: current.id },
      { label: "Name", key: "name", value: current.name },
      { label: "Icon (SFSymbol)", key: "icon", value: current.icon },
      { label: "Color (Hex)", key: "color", value: current.color },
      { label: "Target (Goal)", key: "target", value: String(current.target) }
    ];

    fields.forEach(field => {
      const row = new UITableRow();
      row.height = 70;
      row.dismissOnSelect = false;

      const cell = row.addText(field.label.toUpperCase(), String(field.value || "(empty)"));
      cell.titleFont = Font.boldSystemFont(13);
      cell.titleColor = Color.gray();
      cell.subtitleFont = Font.systemFont(16);
      cell.subtitleColor = COLOR_FILLED;

      row.onSelect = async () => {
        const a = new Alert();
        a.title = `Edit ${field.label}`;
        a.addTextField(field.label, String(field.value));
        a.addAction("OK");
        a.addCancelAction("Cancel");
        if (await a.presentAlert() === 0) {
          const val = a.textFieldValue(0);
          current[field.key] = field.key === "target" ? (parseInt(val) || 1) : val;
          await render();
        }
      };
      table.addRow(row);
    });

    const controls = new UITableRow();
    controls.height = 60;

    // Delete on the Left
    if (!isNew) {
      const deleteBtn = controls.addButton("DELETE");
      deleteBtn.titleFont = Font.boldSystemFont(14);
      deleteBtn.onTap = () => {
        data.habits = data.habits.filter(h => h.id !== habit.id);
        saveData(data);
        App.close();
      };
      deleteBtn.centerAligned();
    } else {
      controls.addText(""); // Placeholder if no delete button
    }

    // Save on the Right
    const saveBtn = controls.addButton("SAVE");
    saveBtn.titleFont = Font.boldSystemFont(14);
    saveBtn.onTap = () => {
      if (!current.id || !current.name) return;
      if (isNew) {
        data.habits.push(current);
      } else {
        const index = data.habits.findIndex(h => h.id === habit.id);
        data.habits[index] = current;
      }
      saveData(data);
      App.close();
    };
    saveBtn.centerAligned();

    table.addRow(controls);
    table.reload();
  }

  await render();
  await table.present();
}

async function manualEntry(data) {
  const alert = new Alert();
  alert.title = "Manual Entry";
  data.habits.forEach(h => alert.addAction(h.name));
  alert.addCancelAction("Cancel");

  const idx = await alert.presentSheet();
  if (idx === -1) return;

  const habit = data.habits[idx];
  const picker = new DatePicker();
  const date = await picker.pickDate();
  const dateStr = formatDate(date);

  const countAlert = new Alert();
  countAlert.title = `Set count for ${habit.name}`;
  countAlert.message = `Date: ${dateStr}`;
  countAlert.addTextField("Count", String(habit.history[dateStr] || 0));
  countAlert.addAction("Save");
  countAlert.addCancelAction("Cancel");

  if (await countAlert.presentAlert() === 0) {
    if (!habit.history) habit.history = {};
    habit.history[dateStr] = parseInt(countAlert.textFieldValue(0)) || 0;
    saveData(data);
  }
}

function createWidget(data) {
  const widget = new ListWidget();
  widget.setPadding(PADDING, PADDING, PADDING, PADDING);
  widget.backgroundColor = BACKGROUND_COLOR;

  const numHabits = data.habits.length;
  // Dynamic scale based on habit count
  let scale = 1.0;
  if (numHabits <= 2) scale = 2.8;
  else if (numHabits <= 4) scale = 1.5;

  const dotSize = 8 * scale;
  const iconSize = 16 * scale;
  const fontSize = 12 * scale;

  let numDays = 20;
  if (config.widgetFamily === "small") numDays = 7;
  if (config.widgetFamily === "large") numDays = 28;

  // Adjust numDays to fit screen if scale is high
  if (scale > 1.5 && config.widgetFamily !== "small") {
    numDays = 12;
  }

  const dates = [];
  for (let i = numDays - 1; i >= 0; i--) {
    const d = new Date();
    d.setDate(d.getDate() - i);
    dates.push(formatDate(d));
  }

  widget.addSpacer();

  data.habits.forEach((habit, idx) => {
    const row = widget.addStack();
    row.layoutHorizontally();
    row.centerAlignContent();
    row.url = `scriptable:///run/${encodeURIComponent(Script.name())}?habitId=${habit.id}&action=increment`;

    row.addSpacer(8); // Left margin

    const iconSymbol = SFSymbol.named(habit.icon || "star.fill");
    const iconElement = row.addImage(iconSymbol.image);
    iconElement.imageSize = new Size(iconSize, iconSize);
    iconElement.tintColor = new Color(habit.color || "#ffffff");

    row.addSpacer(8); // Reduced gap between icon and dots

    const dotsStack = row.addStack();
    dotsStack.layoutHorizontally();
    dotsStack.centerAlignContent();

    // Responsive dot cropping logic
    // Approximate widget widths: Small ~155, Medium/Large ~329
    const widgetWidth = (config.widgetFamily === "small" ? 155 : 329);
    const reservedWidth = (PADDING * 2) + 8 + iconSize + 8 + (fontSize * 1.5) + 20;
    const availableWidth = widgetWidth - reservedWidth;
    const maxDots = Math.max(1, Math.floor(availableWidth / (9 * scale)));
    const visibleDates = dates.slice(-maxDots);

    visibleDates.forEach(dateStr => {
      const count = habit.history ? (habit.history[dateStr] || 0) : 0;
      const opacity = Math.min(count / (habit.target || 1), 1.0);

      const dotContainer = dotsStack.addStack();
      dotContainer.size = new Size(9 * scale, dotSize + 4 * scale);
      dotContainer.centerAlignContent();

      const dot = dotContainer.addText("â—");
      dot.font = Font.systemFont(dotSize);

      dot.textColor = new Color(habit.color || "#ffffff", count > 0 ? opacity : 0.15);
    });

    row.addSpacer();

    const todayCount = habit.history ? (habit.history[formatDate(new Date())] || 0) : 0;
    const counterStack = row.addStack();
    // Counter should be wide enough to not wrap
    const counterText = counterStack.addText(String(todayCount));
    counterText.font = new Font("Menlo-Bold", fontSize);
    counterText.textColor = new Color(habit.color || "#ffffff", 0.9);

    if (idx < numHabits - 1) {
      widget.addSpacer();
    }
  });

  if (numHabits === 0) {
    const msg = widget.addText("No habits configured.");
    msg.font = MENLO_REGULAR;
    msg.textColor = COLOR_FILLED;
  }

  widget.addSpacer();

  return widget;
}

// ðŸ”µ MAIN EXECUTION
loadTheme();
const data = loadData();

if (config.runsInApp) {
  const alert = new Alert();
  alert.title = "Habit Tracker Admin";
  alert.addAction("Manage Habits");
  alert.addAction("Manual Entry");
  alert.addAction("Select Theme");
  alert.addAction("Export Data");
  alert.addCancelAction("Exit");

  const selection = await alert.presentSheet();

  if (selection === 0) {
    await manageHabits(data);
  } else if (selection === 1) {
    await manualEntry(data);
  } else if (selection === 2) {
    const themeChanged = await selectTheme();
    if (themeChanged) applyTheme(Keychain.get(THEME_KEY));
  } else if (selection === 3) {
    await Share.file(DATA_PATH);
  }

  const w = createWidget(data);
  await w.presentMedium();
  Script.complete();
} else {
  const w = createWidget(data);
  Script.setWidget(w);
  Script.complete();
}
